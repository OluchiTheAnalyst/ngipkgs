// SPDX-License-Identifier: MPL-2.0        
// Copyright (c) 2023 Leon van Kammen/NLNET 
package xrfragment;

import xrfragment.Parser;
import xrfragment.XRF;

/**
 * <link rel="stylesheet" href="style.css"/>
 * <link href="https://fonts.cdnfonts.com/css/montserrat" rel="stylesheet"/>
 *
 * > version 1.0.0
 *
 * date: $(date +"%Y-%m-%dT%H:%M:%S%z") (generated by \`./make doc\`)<br>
 * [![Actions Status](https://github.com/coderofsalvation/xrfragment/workflows/test/badge.svg)](https://github.com/coderofsalvation/xrfragment/actions)
 *
 * # XRFragment Grammar 
 *
 * ```
 *     reserved    = gen-delims / sub-delims
 *     gen-delims  = "#" / "&"                      
 *     sub-delims  = "," / "|" / "="
 * ```
 * <br>
 *
 * > Example: `://foo.com/my3d.asset#pos=1,0,0&prio=-5&t=0,100|100,200`
 *
 * <br>
 *
 * | Explanation | |
 * |-|-|
 * | `x=1,2,3` | vector/coordinate argument e.g. |
 * | `x=foo\|bar|1,2,3|1.0` | the `\|` character is used for:<br>1.specifying `n` arguments for xrfragment `x`<br>2. roundrobin of values (in case provided arguments exceeds `n` of `x` for #1) when triggered by browser URI (clicking `href` e.g.)|
 * | `https://x.co/1.gltf||xyz://x.co/1.gltf` | multi-protocol/fallback urls  |
 * | `.mygroup` | query-alias for `class:mygroup` |
 *
 * > Focus: hasslefree 3D vector-data (`,`), multi-protocol/fallback-linking & dynamic values (`|`), and CSS-piggybacking (`.mygroup`) 
 *
 * # URI parser
 * > icanhazcode? yes, see [URI.hx](https://github.com/coderofsalvation/xrfragment/blob/main/src/xrfragment/URI.hx)
 */

@:expose                                                                   // <- makes the class reachable from plain JavaScript
@:keep                                                                     // <- avoids accidental removal by dead code elimination
class URI {
    @:keep
    public static function parse(url:String,filter:Int):haxe.DynamicAccess<Dynamic> {
      var store:haxe.DynamicAccess<Dynamic> = {};                      //  1. store key/values into a associative array or dynamic object
      if( url.indexOf("#") == -1 ) return store;
      var fragment:Array<String>    = url.split("#");                      //  1. fragment URI starts with `#`
      var splitArray:Array<String>  = fragment[1].split('&');              //  1. fragments are split by `&`
        for (i in 0...splitArray.length) {                                 //  1. loop thru each fragment

        var splitByEqual = splitArray[i].split('=');                       //  1. for each fragment split on `=` to separate key/values 
        var regexPlus  = ~/\+/g;                                           //  1. fragment-values are urlencoded (space becomes `+` using `encodeUriComponent` e.g.)
        var key:String = splitByEqual[0];
				var value:String = "";
        if (splitByEqual.length > 1) {
          value = StringTools.urlDecode(regexPlus.split(splitByEqual[1]).join(" "));
        }
				var ok:Bool = Parser.parse(key,value,store);                 //  1. every recognized fragment key/value-pair is added to a central map/associative array/object
      }
      if( filter != null && filter != 0 ){
        for (key in store.keys()) {
            var xrf:XRF = store.get(key);
            if( !xrf.is( filter ) ){ 
							store.remove(key);
						}
        }
      }
      return store;
    }
}
